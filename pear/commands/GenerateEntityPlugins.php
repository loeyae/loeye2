<?php

/**
 * GenerateEntityPlugins.php
 *
 * Licensed under the Apache License, Version 2.0 (the "License"),
 * see LICENSE for more details: http://www.apache.org/licenses/LICENSE-2.0.
 *
 * @author  Zhang Yi <loeyae@gmail.com>
 * @version SVN: $Id: Zhang Yi $
 */

namespace loeye\commands;

use loeye\console\Command;
use \Symfony\Component\Console\{
    Input\InputInterface,
    Output\OutputInterface
};

/**
 * GenerateEntityPlugins
 *
 * @author   Zhang Yi <loeyae@gmail.com>
 */
class GenerateEntityPlugins extends Command
{

    use \loeye\console\helper\EntityGeneratorTraite;

    protected $args                   = [
        ['property', 'required' => true, 'help' => 'The application property name.']
    ];
    protected $params                 = [
        ['db-id', 'd', 'required' => false, 'help' => 'database setting id', 'default' => 'default'],
        ['filter', 'f', 'required' => false, 'help' => 'filter', 'default' => null],
        ['force', null, 'required' => false, 'help' => 'force update file', 'default' => false],
    ];
    protected $name                   = 'loeye:generate-entity-plugins';
    protected static $_template       = <<<'EOF'
<?php

namespace <namespace>;

use \loeye\std\Plugin;

/**
 * <className>
 *
 * This class was generated by the loeye2. Add your own custom
 * server methods below.
 */
abstract class <className> extends Plugin
{

    protected $inDataKey = '<className>_input';
    protected $outDataKey = '<className>_output';
    protected $outErrorsKey = '<className>_errors';

    /**
     *
     * @var \loeye\database\Server
     */
    protected $server;

    protected $dbId = 'default';

    protected $serverName;

    /**
     * process
     *
     * @param \loeye\base\Context $context context
     * @param array               $inputs  inputs
     *
     * @return void
     * @SuppressWarnings(PHPMD.UnusedFormalParameter)
     */
    public function process(\loeye\base\Context $context, array $inputs)
    {
        $type = \loeye\base\Utils::getContextData($context, $inputs, $this->dbId);
        $rfc = new \ReflectionClass($this->serverName);
        $this->server = $rfc->newInstance($context->getAppConfig(), $type);
        $result = $this->execute($context, $inputs, $type);
        $data = null;
        $error = null;
        \loeye\base\Utils::filterResult($result, $data, $error);
        \loeye\base\Utils::setContextData($data, $context, $inputs, $this->outDataKey);
        if ($error) {
            \loeye\base\Utils::addErrors($error, $context, $inputs, $this->outErrorsKey);
        }
    }

    abstract protected function execute(\loeye\base\Context $context, array $inputs, $type);

}
EOF;
    protected static $_pluginTemplate = <<<'EOF'
<?php

namespace <namespace>;

/**
 * <className>
 *
 * This class was generated by the loeye2. Add your own custom
 * server methods below.
 */
class <className> extends <abstractClassName>
{

    protected $inDataKey = '<className>_input';
    protected $outDataKey = '<className>_output';
    protected $outErrorsKey = '<className>_errors';

    /**
     *
     * @var <serverClass>
     */
    protected $server;

    protected $serverName = <serverClass>::class;

    /**
     * excute
     *
     * @param \loeye\base\Context $context context
     * @param array               $inputs  inputs
     * @param string              $type    db setting id
     *
     * @return <returnType>
     * @SuppressWarnings(PHPMD.UnusedFormalParameter)
     */
    protected function execute(\loeye\base\Context $context, array $inputs, $type)
    {
<paramsStatement>
        return $this->server-><method>(<params>);
    }

}
EOF;
    private static $_statement        = <<<'EOF'
        $<param> = \loeye\base\Utils::getData($context, '<className>_<param>');
EOF;

    /**
     * generateFile
     *
     * @param \Symfony\Component\Console\Style\SymfonyStyle $ui
     * @param \Doctrine\Persistence\Mapping\ClassMetadata   $metadata
     * @param string                                        $namespace
     * @param string                                        $destPath
     */
    protected function generateFile(\Symfony\Component\Console\Style\SymfonyStyle $ui, \Doctrine\Persistence\Mapping\ClassMetadata $metadata, $namespace, $destPath, $force)
    {
        $entityName        = $this->getEntityName($metadata->reflClass->name);
        $namespace         .= '\\' . $entityName;
        $destPath          .= D_S . $entityName;
        $abstractClassName = 'Abstract' . ucfirst($entityName) . 'BasePlugin';
        $this->writeAbstactPluginClass($ui, $namespace, $abstractClassName, $destPath, $force);
        $serverClass       = $this->getServerClass($metadata->reflClass->name);
        $this->writePluginClass($ui, $namespace, $entityName, $abstractClassName, $serverClass, $destPath, $force);
    }

    /**
     *
     * @param InputInterface $input
     *
     * @return string
     */
    protected function getDestPath(InputInterface $input)
    {
        $destPath = PROJECT_DIR . D_S . 'plugins' . D_S . $input->getArgument('property');
        return $destPath;
    }

    /**
     * getServerClass
     *
     * @param string $className
     * @return type
     */
    protected function getServerClass($className)
    {
        return '\\' . str_replace('entity', 'server', $className) . 'Server';
    }

    /**
     * getEntityName
     *
     * @param string $fullClassName
     * @return string
     */
    protected function getEntityName($fullClassName)
    {
        return lcfirst(substr($fullClassName, strrpos($fullClassName, '\\') + 1));
    }

    /**
     * generateAbstractPluginClass
     *
     * @param string $namespace
     * @param string $className
     * @return string
     */
    protected function generateAbstractPluginClass($namespace, $className)
    {
        $variables = [
            '<namespace>' => $namespace,
            '<className>' => $className,
        ];

        return str_replace(array_keys($variables), array_values($variables), self::$_template);
    }

    /**
     * generatePluginClass
     *
     * @param string $namespace
     * @param string $className
     * @return string
     */
    protected function generatePluginClass($namespace, $className, $abstractClassName, $serverClass, $method, $paramsStatement, $params, $returnType)
    {
        $variables = [
            '<namespace>'         => $namespace,
            '<className>'         => $className,
            '<abstractClassName>' => $abstractClassName,
            '<serverClass>'       => $serverClass,
            '<method>'            => $method,
            '<paramsStatement>'   => $paramsStatement,
            '<params>'            => $params,
            '<returnType>'        => $returnType,
        ];

        return str_replace(array_keys($variables), array_values($variables), self::$_pluginTemplate);
    }

    /**
     * writeAbstactPluginClass
     *
     * @param \Symfony\Component\Console\Style\SymfonyStyle $ui
     * @param string         $namespace
     * @param string         $className
     * @param string         $outputDirectory
     * @param boolean        $force
     */
    public function writeAbstactPluginClass(\Symfony\Component\Console\Style\SymfonyStyle $ui, $namespace, $className, $outputDirectory, $force = false)
    {
        $fullAbstractClassName = $namespace . '\\' . $className;
        $ui->text(sprintf('Processing Server "<info>%s</info>"', $fullAbstractClassName));
        $code                  = $this->generateAbstractPluginClass($namespace, $className);

        $this->writeFile($outputDirectory, $className, $code, $force);
    }

    /**
     * write plugin class
     *
     * @param \Symfony\Component\Console\Style\SymfonyStyle $ui
     * @param string                                        $namespace
     * @param string                                        $className
     * @param string                                        $abstractClassName
     * @param string                                        $serverClass
     * @param string                                        $outputDirectory
     * @param bool                                          $force
     */
    public function writePluginClass(\Symfony\Component\Console\Style\SymfonyStyle $ui, $namespace, $className, $abstractClassName, $serverClass, $outputDirectory, $force = false)
    {
        $refClass = new \ReflectionClass($serverClass);
        $methods  = $refClass->getMethods();
        foreach ($methods as $method) {
            if ($method->isConstructor() || $method->isFinal()) {
                continue;
            }
            $methodName = $method->getName();
            $returnType = $method->getReturnType();
            if ($returnType == 'loeye\database\object') {
                $returnType = str_replace('server', 'entity', substr($serverClass, 0, -6));
            }
            $nClassName = ucfirst($className) . ucfirst($methodName) . 'Plugin';

            $fullClassName   = $namespace . '\\' . $nClassName;
            $ui->text(sprintf('Processing Server "<info>%s</info>"', $fullClassName));
            $paramsStatement = $this->generateParamsStatement($method, $nClassName);
            $params          = $this->generateParams($method);
            $code            = $this->generatePluginClass($namespace, $nClassName, $abstractClassName, $serverClass, $methodName, $paramsStatement, $params, $returnType);

            $this->writeFile($outputDirectory, $nClassName, $code, $force);
        }
    }

    /**
     * generate params statement
     *
     * @param \ReflectionMethod $method
     * @param string            $className
     * @return string
     */
    protected function generateParamsStatement(\ReflectionMethod $method, $className)
    {
        $params = $method->getParameters();
        if ($params) {
            $content = [];
            foreach ($params as $param) {
                $content[] = $this->generateParamterStatement($param, $className);
            }
            return implode("\r\n", $content);
        }
        return '';
    }

    /**
     * generate paramter statement
     *
     * @param \ReflectionParameter $param
     * @param string               $className
     * @return string
     */
    protected function generateParamterStatement(\ReflectionParameter $param, $className)
    {

        $variables = [
            '<param>'     => $param->getName(),
            '<className>' => $className,
        ];

        return str_replace(array_keys($variables), array_values($variables), self::$_statement);
    }

    /**
     * generate params
     *
     * @param \ReflectionMethod $method
     * @return string
     */
    protected function generateParams(\ReflectionMethod $method)
    {
        $params  = $method->getParameters();
        $initial = '';
        if ($params) {
            return array_reduce($params, function($carry, $item) {
                if ($carry) {
                    $carry .= ', $' . $item->getName();
                } else {
                    $carry = '$' . $item->getName();
                }
                return $carry;
            }, $initial);
        }
        return $initial;
    }

}
